Code architecture notes
-----------------------

This document isn't intended as a tutorial, but as global indications on how the
code is organised.


Building
--------
before building, you need to build the addressable assets. 

- Open the addressable window:
    - Window > Assets Management > Addressable on older ddressable package 
    - Windows > Assets Management > Addressable > Group on newer package (1.8 >)
- On the top toolbar on the window :
	- click on 

This will build all the asset bundle for the current platform and store theme in the Library folder.

You can now hit the Build (or Build and Run) button in the Build Window (File > Build Settings...).
The Addressable system will take care of trasnfering the asset bundle in the streaming folder before
building so it can load it at runtime. 

Services
--------

By default all the services are disabled. When you enable all services, switch to a mobile
platform as some services (e.g. Ads) only works on mobile platforms.

There is a special case for Unity In App Purchase : once you enable in app purchase
in the service windows, it will import a package into your project. Check in
'Plugins/UnityPurchasing' folder and you should see a UnityIAP and UnityChannel package.
Double click on UnityIAP first, import its content, then on UnityChannel. IAP should now
work in your project.

Now go into 'Plugins/UnityPurchasing/Resources' and look for UIFakeStoreCanvas
prefab, and change the Canvas sort order to 100. That will make it appear on
top of all canvas in the game, useful to test IAP in editor.

Ads integrations
----------------

Ads integration is using multiple placementID. That allow to define different behaviour per ads.
If you look at the ads script (e.g. AdsForMission and GameState) you'll see it have a public field called adsPlacementId.
(those value are set in editor to different value that the default rewardVideo)

Now if you log into your Ads Dashboard in a browser and navigate to your project, click on a platform,
you will have a list of Ad Placement. There you can add new placement. By default Trash Dash use 2 in addition
to the default "rewardVideo" and "Video" :

- reviveVideo, used to have a second chance after game over
- missionVideo, used to get a thrid possible missions.


Game States
-----------

The whole game is using a state machine to handle the different states of the
game : Loadout, Game and Gameover.
The State Machine, called GameManager (Scripts/GameManager) is manually updating
the state on the top of its states list. When pushing a new state on top, you
can decide to pop the previous one or leave it and place the new one on top.
That allow things like pushing the GameOver state on top of the Game State,
keeping all game state intact to go back to it as it was.

Store
-----

The store could have been made with a state, but for the purpose of demoing
another technique, it uses additive scene loading.
The store is a separate scene with no camera and only UI. This allows us to load
that scene additively over any state (Loadout or Gameover) and unload when exit.

Addressable
-----------

Theme and Characters are in AssetBundles, defined through the Addressable Assets
system. That mean that to add a new character, just make the prefab addressable
and don't forget to add the label "character" to it. You can then place it in
any Addressable Group, even a remote one, and the application will fetch it from
the server on startup.

Save File
---------

The save file is stored locally. This is to keep the project
simple, but a full product would require some kind of validation linked to the
phone or an account. With the local save file, someone could potentially exploit items.

Shaders
-------

The game use custom shaders for most of its objects. This is due to the world
curving downward, to both give an impression of longer distance, and to hide the
horizon and the worst of the "popping" (sudden apparition) of the track piece being spawned.
There is also a shader to rotate the fishbones. It is way more efficient to do
it in the shader than with a script on each fishbones touching the transform, or
through an animator.

Link.xml
--------

The link.xml file you can find in the Assets folder is used to exclude some
classes from the code stripping that IL2CPP do. IL2CPP use static code analysis
to strip all unused assemblies, but in some cases (dynamic reflections etc.)
it can miss some, stripping them & thus resulting in compile or runtime error.
Adding them to link.xml forces Unity to keep those assemblies even if it
can't detect their use.
See [https://docs.unity3d.com/Manual/iphone-playerSizeOptimization.html] for
more complete info.
